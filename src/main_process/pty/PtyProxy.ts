/*
 * Copyright 2014-2016 Simon Edwards <simon@simonzone.com>
 *
 * This source code is licensed under the MIT license which is detailed in the LICENSE.txt file.
 */
import * as child_process from 'child_process';
import {Event} from 'extraterm-extension-api';
import * as fs from 'fs';
import * as _ from 'lodash';
import * as path from 'path';

import {Pty, BufferSizeChange} from '../../pty/Pty';
import {PtyConnector, PtyOptions} from './PtyConnector';
import {Config} from '../../Config';
import {Logger, getLogger} from '../../logging/Logger';
import log from '../../logging/LogDecorator';
import * as SourceDir from '../../SourceDir';
import {EventEmitter} from '../../utils/EventEmitter';


const DEBUG_FINE = false;

const MAXIMUM_WRITE_BUFFER_SIZE = 64 * 1024;

const _log = getLogger("ptyproxy");

const TYPE_CREATE = "create";
const TYPE_CREATED = "created";
const TYPE_WRITE = "write";
const TYPE_OUTPUT = "output";
const TYPE_RESIZE = "resize";
const TYPE_CLOSED = "closed";
const TYPE_TERMINATE = "terminate";
const TYPE_PERMIT_DATA_SIZE = "permit-data-size";
const TYPE_OUTPUT_WRITTEN = "output-written";

interface ProxyMessage {
  type: string;
  id: number;
}

interface CreatePtyMessage extends ProxyMessage {
  argv: string[];
  rows: number;
  columns: number;
  env: { [key: string]: string; };
  
  // the id field is not user for this message type.
}

interface CreatedPtyMessage extends ProxyMessage {
}

interface WriteMessage extends ProxyMessage {
  data: string;
}

interface ResizeMessage extends ProxyMessage {
  rows: number;
  columns: number;
}

interface PermitDataSizeMessage extends ProxyMessage {
  size: number;
}

// Output generated by the process on the other side of the pty.
interface OutputMessage extends ProxyMessage {
  data: string;
}

interface OutputWrittenMessage extends ProxyMessage {
  chars: number;
}

interface ClosedMessage extends ProxyMessage {
}

interface TerminateMessage extends ProxyMessage {  
}

const NULL_ID = -1;


class ProxyPty implements Pty {
  
  private _id: number = NULL_ID;
  private _writeFunc: (id: number, msg: ProxyMessage) => void = null;
  
  // Pre-open write queue.
  private _writeQueue: ProxyMessage[] = [];
  private _live = true;
  private _outstandingWriteDataCount = 0;
  
  private _onDataEventEmitter = new EventEmitter<string>();
  private _onExitEventEmitter = new EventEmitter<void>();
  private _onAvailableWriteBufferSizeChangeEventEmitter = new EventEmitter<BufferSizeChange>();

  onData: Event<string>;
  onExit: Event<void>;
  onAvailableWriteBufferSizeChange: Event<BufferSizeChange>;

  constructor(writeFunc) {
    this._writeFunc = writeFunc;

    this.onData = this._onDataEventEmitter.event;
    this.onExit = this._onExitEventEmitter.event;
    this.onAvailableWriteBufferSizeChange = this._onAvailableWriteBufferSizeChangeEventEmitter.event;
  }
  
  getId(): number {
    return this._id;
  }
  
  setId(id: number): void {
    this._id = id;
    if (this._live) {
      this._writeQueue.forEach( (msg) => {
        msg.id = this._id;
        this._writeFunc(this._id, msg);
      });
      this._writeQueue = [];
    }
  }
  
  private _writeMessage(id: number, msg: ProxyMessage): void {
    if (this._live) {
      if (this._id === -1) {
        // We don't know what the ID of the pty in the proxy is.
        // Queue up this message for later.
        this._writeQueue.push(msg);
      } else {
        this._writeFunc(this._id, msg);
      }
    }
  }
  
  _charsWritten(chars: number): void {
    this._outstandingWriteDataCount -= chars;
    this._onAvailableWriteBufferSizeChangeEventEmitter.fire(
      {totalBufferSize: MAXIMUM_WRITE_BUFFER_SIZE, availableDelta: chars});
  }

  write(data: string): void {
    this._outstandingWriteDataCount += data.length;
    const msg: WriteMessage = { type: TYPE_WRITE, id: this._id, data: data };
    this._writeMessage(this._id, msg);
  }

  getAvailableWriteBufferSize(): number {
    return MAXIMUM_WRITE_BUFFER_SIZE - this._outstandingWriteDataCount;
  }

  resize(cols: number, rows: number): void {
    const msg: ResizeMessage = { type: TYPE_RESIZE, id: this._id, rows: rows, columns: cols };
    this._writeMessage(this._id, msg);
  }
  
  permittedDataSize(size: number): void {
    const msg: PermitDataSizeMessage = { type: TYPE_PERMIT_DATA_SIZE, id: this._id, size: size };
    this._writeMessage(this._id, msg);
  }

  data(data: string): void {
    if (this._live) {
      this._onDataEventEmitter.fire(data);
    }
  }
  
  exit(): void {
    this._onExitEventEmitter.fire(undefined);
    this._live = false;
  }
  
  destroy(): void {    
  }
  
  getCwd(): string {
      return null;
  }
}

function findCygwinPython(cygwinDir: string): string {
  const binDir = path.join(cygwinDir, 'bin');
  _log.info("Cygwin bin directory is ", binDir);
  if (fs.existsSync(binDir)) {
    const pythonRegexp = /^python3.*m\.exe$/;
    const binContents = fs.readdirSync(binDir);
    const pythons = binContents.filter( name => pythonRegexp.test(name) );
    return pythons.length !== 0 ? path.join(binDir,pythons[0]) : null;
  }
  return null;
}

export function factory(config: Config): PtyConnector {
  const ptys: ProxyPty[] = [];
  const sessionProfile = config.expandedProfiles[0];
  const pythonExe = findCygwinPython(sessionProfile.cygwinDir);
  
  if (pythonExe !== null) {
    _log.info("Found Python 3 exe at ", pythonExe);
  } else {
    const msg = "Unable to find Python 3 exe.";
    _log.severe("Unable to find Python 3 exe.");
    throw new Error(msg);
  }

  const serverEnv = _.clone(process.env);
  serverEnv["PYTHONIOENCODING"] = "utf-8:ignore";
  const proxy = child_process.spawn(pythonExe, [path.join(SourceDir.path, "main_process/pty/python/ptyserver2.py")], {env: serverEnv});
  let messageBuffer = "";

  proxy.stdout.on('data', function(data: Buffer) {
    if (DEBUG_FINE) {
      _log.debug("server -> main: ", data.toString("utf8"));
    }
    messageBuffer = messageBuffer + data.toString('utf8');
    processMessageBuffer();
  });

  proxy.stderr.on('data', function (data: Buffer) {
    _log.warn('ptyproxy process stderr: ', data.toString());
  });

  proxy.on('close', function (code) {
    if (DEBUG_FINE) {
      _log.debug('bridge process closed with code: ', code);
    }
  });
  
  proxy.on('exit', function (code) {
    if (DEBUG_FINE) {
      _log.debug('bridge process exited with code: ', code);
    }
  });
  
  proxy.on('error', (err) => {
    _log.severe("Failed to start process " + pythonExe + ". ", err);
  });

  function processMessageBuffer(): void {
    while (true) {
      const end = messageBuffer.indexOf('\n');
      if (end !== -1) {
        const msgString = messageBuffer.slice(0, end);
        messageBuffer = messageBuffer.slice(end+1);
        const msg = <ProxyMessage> JSON.parse(msgString);
        processMessage(msg);
      } else {
        break;
      }
    }
  }

  function processMessage(msg: ProxyMessage): void {
    const msgType = msg.type;
    
    if (msgType === TYPE_CREATED) {
      const createdPtyMsg = <CreatedPtyMessage> msg;
      for (let i=0; i<ptys.length; i++) {
        const pty = ptys[i];
        if (pty.getId() === NULL_ID) {
          pty.setId(createdPtyMsg.id);
          break;
        }
      }
      return;
    }
    
    if (msgType === TYPE_OUTPUT) {
      const outputMsg = <OutputMessage> msg;
      const pty = findPtyById(outputMsg.id);
      if (pty !== null) {
        pty.data(outputMsg.data);
      }
      return;
    }
    
    if (msgType === TYPE_CLOSED) {
      const closedMsg = <ClosedMessage> msg;
      const pty = findPtyById(closedMsg.id);
      if (pty !== null) {
        pty.exit();
      }
      return;
    }

    if (msgType === TYPE_OUTPUT_WRITTEN) {
      const outputWrittenMsg = <OutputWrittenMessage> msg;
      const pty = findPtyById(outputWrittenMsg.id);
      if (pty !== null) {
        pty._charsWritten(outputWrittenMsg.chars);
      }      
    }
  }
  
  function findPtyById(id: number): ProxyPty {
    for (let i=0; i<ptys.length; i++) {
      if (ptys[i].getId() === id) {
        return ptys[i];
      }
    }
    return null;
  }
  
  function sendMessage(id: number, msg: ProxyMessage): void {
    const msgText = JSON.stringify(msg);
    if (DEBUG_FINE) {
      _log.debug("main -> server: ", msgText);
    }
    proxy.stdin.write(msgText + "\n", 'utf8');
  }
  
  function spawn(file: string, args: string[], opt: PtyOptions): Pty {
    let rows = 24;
    let columns = 80;
    if (DEBUG_FINE) {
      _log.debug("ptyproxy spawn file: ", file);
    }
    if (opt !== undefined) {
      rows = opt.rows !== undefined ? opt.rows : rows;
      columns = opt.cols !== undefined ? opt.cols : columns;
    }
    const pty = new ProxyPty(sendMessage);
    ptys.push(pty);
    const msg: CreatePtyMessage = { type: TYPE_CREATE, argv: [file, ...args], rows: rows, columns: columns, id: -1, env: opt.env };
    sendMessage(null, msg);
    return pty;
  }
  
  function destroy() {
    const msg: TerminateMessage = { type: TYPE_TERMINATE, id: -1 };
    sendMessage(null, msg);
  }
  
  return {
    spawn: spawn,
    destroy: destroy
  };
}
